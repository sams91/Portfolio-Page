<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Var, Let, and Const</title>
    <link rel="stylesheet" href="/css/blogs.css">
</head>
<body>
    
<div class="blogs">
    <div class="blog-box">
        <!--Blog Image-->
        <div class="blog-img">
            <img src="/assets/var 800 x 500.jpg" alt="Var">
        </div>

        <!--Blog Text-->
        <div class="blog-text">
            <div class="blog-title">
                <h1>Var, Let, and Const</h1>
            </div>
            
            <br>
            <p>
                What are Var, Let, and Const and how are they used? The short answer is they are used 
                to declare variables. Var is part of the original version of JavaScript. Let and Const 
                came with ECMAScript 6 (AKA ES6). To dive a little deeper I’ll first bring up the 
                concept of scope.
                <br><br><br><br><br><br>

                <img src="/assets/scope2 800 x 500.jpg" alt="scope">
                <br><br>

                I like to think of scope as a declared area of operation, practice, interest, intent, 
                or focus. It’s a kind of boundary put in place by the subject you are focused on or 
                working with. The scope of this blog is declaring variables for instance. The difference 
                between compiled and interpreted programming languages is an important topic but would 
                be outside the scope of this particular blog.
                <br><br>

                Scope is very important when declaring variables. It sets the boundaries for where 
                variables can and can’t be accessed. A variable scoped to a single function cannot 
                be accessed by anything outside of that function, but a variable scoped globally 
                could be accessed anywhere in the code. Improperly scoped variables can have 
                unintended consequences. The two main types of scope for declaring variables are 
                local and global. Local can be further divided into function and block. 
                <br><br>

                <div class="blog-title">
                    <h2>Functional Scope</h2>
                </div>

                <br>
                Now that we have that sorted out let’s take a look at a function using var, let, 
                and const. First, I will try to access them from outside the function and see what 
                happens:
                <br><br>

                <pre><code>
                
                    function s() {
                        let space = "The Final Frontier";
                        const these = "Are the voyages";
                        var of = "The starship";
                    }
                    
                    console.log(space);
                    console.log(these);
                    console.log(of);                    

                </code></pre> 

                In this function I have declared 3 different variables and have attempted to access 
                all of them outside of the function. Here is what is printed in the console for the 
                space variable: 
                <br><br>

                <div class="con">
                    site.js:11 
                    Uncaught ReferenceError: space is not defined
                    at site.js:11:13
                </div> 
                <br><br>

                The scope of the space variable is limited to the function in which it was declared. 
                This means it doesn’t exist outside of that function, which is why we get the error 
                when trying to print it to the console. 
                <br><br>
                Here is what the console will print when I try to access the other 2 variables in the same way:
                 <br><br>

                 <div class="con">
                    site.js:12 
                    Uncaught ReferenceError: these is not defined
                    at site.js:12:13
                    <br>
                    site.js:13         
                     Uncaught ReferenceError: of is not defined
                    at site.js:13:13
                 </div>
                 <br><br>

                 As you can see, these variables cannot be accessed outside of the function they were 
                 declared in. What if I put the command to print the variables inside the function and 
                 call the function? 
                 <br><br>

                <pre><code>
                    function s() {
   
                        let space = "The Final Frontier";
                        const these = "Are the voyages";
                        var of = "The starship";
                    
                        console.log(space);
                        console.log(these);
                        console.log(of);
                    }
                    
                    s();
                    
                </code></pre> 
                <br><br>

                Here is the output:
                <br><br>

                <div class="con">
                    site.js:10 The Final Frontier
                    <br>
                    site.js:11 Are the voyages
                    <br>
                    site.js:12 The starship
 
                </div> 
                <br><br>
                
                Because the variables are being accessed within the function, the console is able 
                to print them when the function is called. This demonstrates functional scope.

                 <br><br>

                 <div class="blog-title">
                    <h2>Block Scope</h2>
                </div>
                <br><br>

                The scope of variables declared in a block of code is similar to that of functional 
                scope with the exception of var. 
                <br><br>

                <pre><code>
                    {
                        let a = 'apple';
                        const b = 'ball';
                        var c = 'cat';
                    }
                    
                    console.log(a);
                    console.log(b);
                    console.log(c);
                    
                    
                </code></pre> 
                <br>

                In the above code I have declared 3 variables. I’m trying to access them outside 
                the scope of the block they were declared in.  Here is what is printed for each 
                variable in the console:

                 <br><br>

                <div class="con">
                    
                    site.js:25 
                    Uncaught ReferenceError: a is not defined
                    at site.js:25:13
                    <br>
                    site.js:26         
                    Uncaught ReferenceError: b is not defined
                    at site.js:26:13
                    <br>
                    cat
                    site.js:27 

                </div>
                <br><br>

                The variables let and const cannot be accessed outside of the block but var can. 
                This means that variables declared with var inside block scope can potentially be 
                overwritten elsewhere and create a bug that may not be easy to find. This is a 
                good reason many people prefer not to use var when declaring variables.

                <br><br>

                <div class="blog-title">
                    <h2>Global Scope</h2>
                </div>
                <br><br>

                A variable declared globally means it exists outside of any function or block and can 
                be accessed anywhere in the code. This also means that var or let variables declared 
                on line 5 could potentially be overwritten on line 2005. Because of this, global 
                variables should be used sparingly. 
                <br><br>

                <pre><code>
                    let sun = "moon";
                    const car = "go";
                    var cow = "milk";

                    function a(){
                    console.log(sun);
                    console.log(car);
                    console.log(cow);
                    }

                    a();


                </code></pre> 
                <br><br>

                Here is the output in the console:

                <br><br>

                <div class="con">
                    site.js:9 moon
                    <br>
                    site.js:10 go
                    <br>
                    site.js:11 milk

                </div>  
                <br><br>

                Notice these variables are declared outside of the function but the function 
                is still able to access them. I can change the let and var variables like this:
                <br><br>

                <pre><code>
                    let sun = "moon";
                    const car = "go";
                    var cow = "milk";

                    function a(){
                        
                        console.log(sun);
                        console.log(car);
                        console.log(cow);
                        
                    }

                    a();

                    cow = "moo";
                    sun = "star";
                    console.log(cow);
                    console.log(sun);
                </code></pre>
                <br><br>

                The console shows this:
                <br><br>

                <div class="con">
                    site.js:9 moon
                    <br>
                    site.js:10 go
                    <br>
                    site.js:11 milk
                    <br>
                    site.js:19 moo
                    <br>
                    site.js:20 star

                </div>
                <br><br>
                First the output of a() is printed in the console showing the original values of the 
                let, const, and var variables. This is immediately followed by the values of the let 
                and var variables after they are overwritten a few lines later. This demonstrates both 
                the power and the danger of using global variables. A global const variable can be 
                accessed anywhere but it’s value can never be changed. The properties of that value 
                can be changed though. Here is an example:
                <br><br>

                <pre><code>
                    const fish = {
                        size: "small",
                        color: "blue",
                        fins: 6
                    }
                    
                    console.log(fish);
                    
                    
                </code></pre>
                <br><br>

                Here is a const variable with the value of fish. This fish variable has 3 properties 
                that can be printed in the console:
                <br><br>

                <div class="con">
                    {size: 'small', color: 'blue', fins: 6} site.js:8
                </div>
                <br><br>

                In this example I could do this:
                <br><br>

                <pre><code>
                    fish.color = "green";
                    
                </code></pre>
                <br><br>
                
                and this would be the result:
                <br><br>

               <div class="con">
                {size: 'small', color: 'green', fins: 6} site.js:12
               </div>
               <br><br>

               I could also do this:
               <br><br>

                <pre><code>
                    fish.feet = 7;
                </code></pre>
                <br><br>

                and the console will show this:
                <br><br>

                <div class="con">
                    {size: 'small', color: 'green', fins: 6, feet: 7}  site.js:16 
                </div>
                <br><br>

                I could not however do this:
                <br><br>

                <pre><code>
                    fish = "in the water";

                </code></pre>
                <br><br>



                The console will show this:
                <br><br>

                <div class="con">
                    site.js:18 
                    <br>
                    Uncaught TypeError: Assignment to constant variable. at site.js:18:6
                    <br>
	                (anonymous)	@	site.js:18

                </div>
                <br><br>

                Once a const variable has been declared you can change the properties of the 
                object it represents but you can’t assign a new value to the object itself. 
                In other words, I can say an object called glass holds water then later say 
                it holds air without any problems but if I try to turn that glass into a 
                space station I’ll get an error (and probably a headache).   
                <br><br>

                <div class="blog-title">
                    <h2>Variable Shadowing</h2>
                </div>
                <br><br>

                Our brief discussion of scope leads us to something called variable shadowing. 
                Variables can shadow each other when you have 2 with the same name and in overlapping 
                scopes. Here is one way it can be done:
                <br><br>

                <pre><code>
                    function way(){
                        let all = "some";
                    
                        if (true){
                            let all = "none";
                            console.log(all);
                        }
                        console.log(all);
                    }
                    
                    way();
                    
                </code></pre>
                <br><br>

                Here we have an if statement inside a function, both with a let variable named “all”. 
                The scope of the 2 variables in the above code is overlapped. This is the output in 
                the console:
                <br><br>

                <div class="con">
                    none   next.js:25
                    <br>
                    some   next.js:27 

                </div>
                <br><br>

                Here is an example using a global variable:
                <br><br>

                <pre><code>
                    let ice = "cold";

                    function snow(){
                        let ice = "water";
                        console.log(ice);
                    }

                    snow();

                    console.log(ice);

                </code></pre>
                <br><br>

                Here is the output:
                <br><br>

                <div class="con">
                    Water   next.js:9
                    <br>
                    cold  next.js:14
                     
                </div>
                <br><br>

                The value of the ice variable is water inside the function, but the global value is 
                cold. First the snow function is called and the water value is printed in the console 
                immediately followed by the global value for ice being printed.
                <br><br>

                <div class="blog-title">
                    <h2>Illegal Shadowing</h2>
                </div>
                <br><br>

                A var variable can be shadowed by a let variable but a let variable cannot be shadowed 
                by a var variable. This is known as illegal shadowing.
                <br><br>

                <pre><code>
                    function time() {
                        var t = "noon";
                        if(true){
                            let t = "morning";
                            console.log(t);
                        }
                    }
                    
                    time();
                    
                </code></pre>
                <br><br>

                In the above code we have a var variable being shadowed by a let variable, which works. 
                Here is the output in the console:
                <br><br>

                <div class="con">
                    morning     next.js:40
                </div>
                <br><br>

                If we switch the var and let variables so the let is being shadowed by var we will get an 
                error:
                <br><br>

                <pre><code>
                    function time() {
                        let t = "noon";
                        if(true){
                            var t = "morning";
                            console.log(t);
                        }
                    }
                    
                    time();
                    
                </code></pre>
                <br><br>

                And here is the output:
                <br><br>

                <div class="con">
                    Uncaught SyntaxError: Identifier 't' has already been declared (at next.js:39:13)
                </div>
                <br><br>

                When thinking about scope and shadowing it’s important to know that while var can be 
                redeclared in the same scope without issue, let and const cannot.
                <br><br>

                <div class="blog-title">
                    <h2>Declaring Variables</h2>
                </div>
                <br><br>

                Variables are little more than containers that store values. They can be declared by 
                using the keyword var, let, or const. A variable can also be left undeclared, meaning 
                it doesn’t use a keyword.
                <br><br>

                <pre><code>
                    let one = 1

                    console.log(one);

                </code></pre>
                <br><br>

                In the above code I have used the keyword let to declare the variable one which has a 
                value of 1. Here is the output printed in the console:
                <br><br>

                <div class="con">
                    1       next.js:62
                </div>
                <br><br>

                When I initialize a variable I am assigning a value to it. In the above code I have 
                initialized the variable one with the value 1. It is possible to declare a variable 
                using var or let without initializing it. When you declare a variable with const you 
                have to initialize it otherwise you will get an error. The same holds true when 
                reinitializing variables, var and let can be reinitialized but not const. Here is 
                what I mean by reinitializing a variable:
                <br><br>

                <pre><code>
                    var c = "crow";
                    c = 6;
                    c = "tree";
                    c = 37
                    console.log(c);

                </code></pre>
                <br><br>

                In the above code the value of c changed from crow to 6 to tree to 37, 
                all without throwing an error. The same could be done if the variable was 
                declared using let, but not const. Here is the output in the console:
                <br><br>

                <div class="con">
                    37        next.js:69
                </div>
                <br><br>

                As you can see, there are 4 values of c declared but only the last value is printed 
                in the console.	
                <br><br>

                <div class="blog-title">
                    <h2>Hoisting</h2>
                </div>
                <br><br>

                During the creation phase of the JavaScript Execution Context, all of the functions, 
                variables, etc. are declared at the top of the code. Then when the code is executed, 
                it checks to see if they exist. Because of this you can use and access code before 
                declaring it. Here is an example:
                <br><br>

                <pre><code>
                    money()

                function money(){
                    let change = "pennies";
                    console.log(change);
                }

                </code></pre>
                <br><br>

                In the above example I have called a function before declaring it. 
                Here is the output in the console:
                <br><br>

                <div class="con">
                    pennies      next.js:80
                </div>
                <br><br>

                Without hoisting the above code would throw an error. To avoid the error, 
                I would need to declare the function before calling it. Here is another 
                example using var:
                <br><br>

                <pre><code>
                    console.log(fork);

                    var fork;

                </code></pre>
                <br><br>

                Here is the output in the console:
                <br><br>

                <div class="con">
                    undefined      next.js:87
                </div>
                <br><br>

                Rather than getting an error we get undefined printed in the console. 
                This is because variables declared with var are given a default initialization 
                of undefined. Variables declared with let or const can be hoisted but they are 
                not given a default value. This means hoisted variables declared with let or const 
                need to be initialized with a value or you will get an error.
                <br><br>

                <pre><code>
                    console.log(fork);

                    let fork;

                </code></pre>
                <br><br>

                The above code would show the following error in the console:
                <br><br>

                <div class="con">
                    next.js:87 
                    <br>
                    Uncaught ReferenceError: Cannot access 'fork' before initialization
                    <br>
                    at next.js:87:13 

                </div>
                <br><br>

                Using const would also throw an error:
                <br><br>

                <pre><code>
                    console.log(fork);

                    const fork;

                </code></pre>
                <br><br>

                Here is the output:
                <br><br>

                <div class="con">
                    next.js:89
                    <br>         
                    Uncaught SyntaxError: Missing initializer in const declaration (at next.js:89:7)

                </div>
                <br><br>

                Now I will initialize the let variable and see what happens:
                <br><br>

                <pre><code>
                    console.log(fork);

                    let fork = 8;

                </code></pre>
                <br><br>

                Here is the output:
                <br><br>

                <div class="con">
                    next.js:87  
                    <br>       
                    Uncaught ReferenceError: Cannot access 'fork' before initialization
                    <br>
                    at next.js:87:13 
             
                </div>
                <br><br>

                Question:
                <br>
                If let and const variables can be hoisted then why am I getting an error? 
                <br><br>

                Explanation:
                <br>
                Let and const variables are hoisted but because they aren’t initialized with a default 
                value they are stuck in something called the temporal dead zone (TDZ) until the initialized 
                variable is evaluated. The temporal dead zone refers to the time between the 
                declaration and initiation of let and const variables. In the above code, the first 
                line would be the TDZ because the let variable isn’t initialized until the second 
                line. Another way of thinking about it would be to say that line 2 is in the scope 
                of line 1 but it hasn’t been initialized yet.


            </p>
        </div>
    </div>
</div>


</body>
</html>